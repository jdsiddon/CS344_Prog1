#!/bin/bash
#

err="Usage: stats {-rows|-cols} [file]"
sort=$1

# Validate command line arguments.
if [[ $# -gt 2 || $# -lt 1 ]]		 	# More than two command line arguments were passed or no command line args.
then
	echo "$err"
	exit 1
elif [ $# -eq 2 ]				# 2 Args were passed so check that the second is a readable file.
then

	if ! [ -r $2 ]				# Make sure file is readable.
	then
		echo "Can't read input"
		exit 1
	else					# File is readable so assign to variable.
		file=$2
	fi
fi

# Arguments valid so lets declare variables.
name=$(echo $1 | cut -c2-2)		# Sort option, the first character following '-' so '-col' means 'file=c'.
row_sum=0
elem_count=0
avg=0
median=0
round_up=0.5
rounded_avg=0
numerator=0
results=calcResults

# $1, temp file, $2=sum, $3=elem_count
function calculate {
	# Calculate median
	sorted_line=($(cat tmp | sort))
	middle=$(($elem_count/2))
	median=${sorted_line[$middle]}		# Grab middle val, if even it will grab the larger of two value, if odd it will grab right in the middle.

	# Calculate average
	numerator=$(($row_sum*10))
	denominator=$elem_count
	avg=$(((($numerator/$denominator)+5)/10))

	# Print out both calculated values.
	echo "$avg $median" >> $results


}

function calcRows {

	# Loop through each line in file. ROWS
	echo "Average Median"		# Print value headings out.
	echo "File: $file"
	while read line
	do
		row_sum=0
		elem=0
		elem_count=0

		# Loop through each value in line.
		for elem in ${line[@]}
		do
			echo "$elem" >> tmp			# Write each element in the line to tmp file.
			row_sum=`expr $row_sum + $elem`		# Add individual value to total row sum.
			elem_count=`expr $elem_count + 1`       # Increment counter for number of elements.
		done

		calculate
		rm tmp

	done < "${file:-/dev/stdin}" 			# $1 is the first command line arg.
}

# Loop through each column in file.
# Converts file to a normal row organized file, then calls the standard calculate function.
function columnConvert {
	columns=5
	tmpInputCopy=tmpInputCopy
	tmpRowFile=tmpRowFile

	# Save stdin or file into a temp file so we can read it multiple times.
	while read data
	do
		echo $data >> $tmpInputCopy
	done < "${file:-/dev/stdin}"

	columns="$(head -n 1 $tmpInputCopy | wc -w)"		# Get the number of columns contained in stdin or file.
	column_itr=0	# Initialize iterator to loop through columns.

	while [ $column_itr -lt $columns ]
	do
		# Create a row from the column elements.
		while read column_string
		do
			# echo $column_string
			column=( $(echo $column_string) )			# Convert column line into an array.
			# echo $column
			echo -ne "${column[$column_itr]} " >> $tmpRowFile	# Place only one character from line into tmp file.

		done < $tmpInputCopy

		echo "" >> $tmpRowFile									# Add newline to the end of the row.
		column_itr=$(($column_itr+1))						# Increment the column counter.
	done

	rm $tmpInputCopy 						#	Remove tmpInputCopy file

}

# This function prints out the results in the $results file.
function printResults {
	while read result_line
	do
		echo $result_line

	done < "$results"
}

if [ "$name" = "c" ]		# Calc by columns.
then
	columnConvert
#	calcRows
#	rm tmpConvert

elif [ "$name" = "r" ]		# Calc by rows.
then
	calcRows
	printResults

else				# Sort option invalid, show err and exit.
	echo $err
	exit 1

fi

exit 0
